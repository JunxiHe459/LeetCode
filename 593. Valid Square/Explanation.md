# Valid Square

做题前：

1. 这个题还是很有意思，值得我多记一点流水账。
2. 第一个思路：先从 4 个点里面找到构成一个正方形对角线的点，因为一根对角线只对应唯一的正方形。找到对角线后就能确定这个正方形其他的两个点，再去判断剩下两个点就可以了。==问题：==无法判断这4个点究竟哪两个是对角线。eg：```p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]```可以判断出```p1, p2```是对角线的两个点。```p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]```就无法判断对角线的两个点了。
3. 第二个思路：先得到 p1 和 p2 组成的一条线。如果要构成一个正方形，p3 可以在的位置有 6 种情况。分别检查这 6 种情况，最后再根据 p1，p2，p3 来检查 p4。太笨了，就没写。
4. 第三个思路，也是比较好的一个思路。从 4 个点中，分别判断两两点之间的距离，一共得到 6 个距离。如果这 4 个点能组成一个正方形，则得到的 6 个距离中，必由 4 个相等距离（正方形的边长） 和 2 个相等距离（正方形的对角线长度）组成。且对角线的长度 > 边长



做题中：

1. ```c++
       unordered_set<int> s({dist(p1, p2),dist(p1, p3),dist(p1, p4),
       					 dist(p2,p3),dist(p2, p4),dist(p3, p4)});
       return !s.count(0) && s.size() == 2;
   ```

   首先检查有无重合的点（count（0））。然后检查 6 个点能否归为两类。



做题后：

1. 在代码中，只检查了 set 的 size 为 2， 那有没有可能是 5 + 1 = 6 或者 3 + 3 = 6呢？为什么一定是4+ 2 = 6呢？ ```!s.count(0)```确保了一定是 4 + 2 = 6.

2. 在代码中，并没有检查 ==对角线的长度 > 边长== 这个条件，为什么？

   eg:  ```p1 = [0,0], p2 = [2,0], p3 = [1,sqrt(3)], p4 = [1,sqrt(3) - 2]```

   会得到 4 个 4

   ​			 2 个 8 - 4 * sqrt(3) 

   程序会 return true 但是这其实不是一个正方形![](C:\Users\123\Desktop\LeetCode\593. Valid Square\1.png)

   但是这里规定了坐标都是 int， 所以不会出现问题。

   

